// Code generated by codegen.go; DO NOT EDIT

package s3protocol

import (
	"fmt"
	"net/http"
	"net/url"
	"strconv"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
)

func newGetObjectInput(req *http.Request) (*s3.GetObjectInput, error) {
	var in s3.GetObjectInput
	header := req.Header
	if header == nil {
		header = make(http.Header)
	}
	query, err := url.ParseQuery(req.URL.RawQuery)
	if err != nil {
		return nil, err
	}
	if v, ok := header["If-Match"]; ok && len(v) > 0 {
		in.IfMatch = aws.String(v[0])
	}
	if v, ok := header["If-Modified-Since"]; ok && len(v) > 0 {
		t, err := http.ParseTime(v[0])
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse If-Modified-Since: %v", err)
		}
		in.IfModifiedSince = aws.Time(t)
	}
	if v, ok := header["If-None-Match"]; ok && len(v) > 0 {
		in.IfNoneMatch = aws.String(v[0])
	}
	if v, ok := header["If-Unmodified-Since"]; ok && len(v) > 0 {
		t, err := http.ParseTime(v[0])
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse If-Unmodified-Since: %v", err)
		}
		in.IfUnmodifiedSince = aws.Time(t)
	}
	if v, ok := query["partNumber"]; ok && len(v) > 0 {
		i, err := strconv.ParseInt(v[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse partNumber: %v", err)
		}
		in.PartNumber = aws.Int64(i)
	}
	if v, ok := header["Range"]; ok && len(v) > 0 {
		in.Range = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Request-Payer"]; ok && len(v) > 0 {
		in.RequestPayer = aws.String(v[0])
	}
	if v, ok := query["response-cache-control"]; ok && len(v) > 0 {
		in.ResponseCacheControl = aws.String(v[0])
	}
	if v, ok := query["response-content-disposition"]; ok && len(v) > 0 {
		in.ResponseContentDisposition = aws.String(v[0])
	}
	if v, ok := query["response-content-encoding"]; ok && len(v) > 0 {
		in.ResponseContentEncoding = aws.String(v[0])
	}
	if v, ok := query["response-content-language"]; ok && len(v) > 0 {
		in.ResponseContentLanguage = aws.String(v[0])
	}
	if v, ok := query["response-content-type"]; ok && len(v) > 0 {
		in.ResponseContentType = aws.String(v[0])
	}
	if v, ok := query["response-expires"]; ok && len(v) > 0 {
		t, err := http.ParseTime(v[0])
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse response-expires: %v", err)
		}
		in.ResponseExpires = aws.Time(t)
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Algorithm"]; ok && len(v) > 0 {
		in.SSECustomerAlgorithm = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Key"]; ok && len(v) > 0 {
		in.SSECustomerKey = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Key-Md5"]; ok && len(v) > 0 {
		in.SSECustomerKeyMD5 = aws.String(v[0])
	}
	if v, ok := query["versionId"]; ok && len(v) > 0 {
		in.VersionId = aws.String(v[0])
	}
	return &in, nil
}
func newHeadObjectInput(req *http.Request) (*s3.HeadObjectInput, error) {
	var in s3.HeadObjectInput
	header := req.Header
	if header == nil {
		header = make(http.Header)
	}
	query, err := url.ParseQuery(req.URL.RawQuery)
	if err != nil {
		return nil, err
	}
	if v, ok := header["If-Match"]; ok && len(v) > 0 {
		in.IfMatch = aws.String(v[0])
	}
	if v, ok := header["If-Modified-Since"]; ok && len(v) > 0 {
		t, err := http.ParseTime(v[0])
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse If-Modified-Since: %v", err)
		}
		in.IfModifiedSince = aws.Time(t)
	}
	if v, ok := header["If-None-Match"]; ok && len(v) > 0 {
		in.IfNoneMatch = aws.String(v[0])
	}
	if v, ok := header["If-Unmodified-Since"]; ok && len(v) > 0 {
		t, err := http.ParseTime(v[0])
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse If-Unmodified-Since: %v", err)
		}
		in.IfUnmodifiedSince = aws.Time(t)
	}
	if v, ok := query["partNumber"]; ok && len(v) > 0 {
		i, err := strconv.ParseInt(v[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("s3protocol: failed to parse partNumber: %v", err)
		}
		in.PartNumber = aws.Int64(i)
	}
	if v, ok := header["Range"]; ok && len(v) > 0 {
		in.Range = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Request-Payer"]; ok && len(v) > 0 {
		in.RequestPayer = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Algorithm"]; ok && len(v) > 0 {
		in.SSECustomerAlgorithm = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Key"]; ok && len(v) > 0 {
		in.SSECustomerKey = aws.String(v[0])
	}
	if v, ok := header["X-Amz-Server-Side-Encryption-Customer-Key-Md5"]; ok && len(v) > 0 {
		in.SSECustomerKeyMD5 = aws.String(v[0])
	}
	if v, ok := query["versionId"]; ok && len(v) > 0 {
		in.VersionId = aws.String(v[0])
	}
	return &in, nil
}
